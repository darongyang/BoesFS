// Code generated by "go run generate.go"; DO NOT EDIT.

package gofs

// 反正我自己也不用宏定义, 所以这里直接将宏定义展开写死
// 要是改了 直接重新 go generate
func checkOp(s string) int {
	switch s {
	case "init":
		return 0
	case "destroy":
		return 1
	case "read":
		return 2
	case "write":
		return 3
	case "lookup":
		return 4
	case "open":
		return 5
	case "mkdir":
		return 6
	case "unlink":
		return 7
	case "rmdir":
		return 8
	case "mknod":
		return 9
	case "create":
		return 10
	case "link":
		return 11
	case "symlink":
		return 12
	case "rename":
		return 13
	case "setattr":
		return 14
	case "getattr":
		return 15
	case "llseek":
		return 16
	case "iterate":
		return 17
	case "mmap":
		return 18
	case "lookup2":
		return 19
	case "statfs":
		return 20
	case "fsync":
		return 21
	default:
		return -1
	}
}

// enum model_map_idx
const (
    REQ_DEF_IDX = iota
    POL_DEF_IDX
    POL_EFF_IDX
    MATCHER_IDX
    DIR_ENTRY_IDX          //  number of dir rules filled in dir map
    SUB_ACT_RULE_IDX       //  only for matcher_sub_act. value : args[0] is allow bitmap ; args[1] is deny bitmap
    MAX_MODEL_IDX
)

// enum matcher
const (
    SUB_OBJ_ACT = iota        //  r.sub == p.sub && r.obj == p.obj && r.act == p.act
    SUB_OBJ            //  r.sub == p.sub && r.obj == p.obj
    SUB_ACT            //  r.sub == p.sub && r.act == p.act
    OBJ_ACT            //  r.obj == p.obj && r.act == p.act
    SUB_OBJ_ACT_ARGS   //  r.sub == p.sub && r.obj == p.obj && r.act == p.act && r.args == p.args
    // SUB_ACT_ARGS 暂时不支持 有ARGS一定要有OBJ和ACT
    OBJ_ACT_ARGS        //  r.obj == p.obj && r.act == p.act && r.args == p.args
)

// enum policy_effect
const (
    EFFECT_ALLOW = iota       //  e = some(where (p.eft == allow))
    EFFECT_DENY         //  e = !some(where (p.eft == deny))
)
